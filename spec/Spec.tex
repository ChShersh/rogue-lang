\documentclass[11pt,a4paper]{article}

\usepackage[thinlines]{easytable}
\usepackage{fullpage}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage[stable]{footmisc}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{bm}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}
\setcounter{section}{-1}

\setlength\parindent{0pt}

%\usepackage[margin=0.4in]{geometry}

\setcounter{MaxMatrixCols}{20}

%\pagenumbering{gobble}

%\definecolor{darkOrange}{RGB}{255, 129, 0}
\definecolor{lightGray}{RGB}{236, 236, 236}
\definecolor{myGreen}{rgb}{0,0.6,0}
\definecolor{darkBlue}{RGB}{27,0,116}

\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

\begin{document}
\lstset{%
    backgroundcolor=\color{lightGray},
    commentstyle=\itshape\color{myGreen},
    extendedchars=true,
    keywordstyle=\bfseries\color{darkBlue},
    language=Java,
    otherkeywords={let,mut,then,else,Int,Double,Bool,true,false,skip},
    numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
    numbersep=5pt
    %stringstyle=\color{mymauve}
}

\begin{flushright}
  Коваников Дмитрий, группа M4138
\end{flushright}

\begin{center}
  \LARGE{Специализация конкретного синтаксиса\\
  для своего языка программирования\\}
\end{center}

\textbf{Язык реализации:} Haskell\\

\textbf{Платформа:} LLVM\\

Ниже приводится список взятых дополнений для языка программирования \textit{Rogue} "--- императивного языка с элементами синтаксиса функциональных языков, 
"--- и возможные улучшения (если найдётся для них время/желание), после чего следует описание конкретных синтаксических конструкций. \\

\textbf{\textit{Усложения:}}
\begin{enumerate}
    \item Синтаксические улучшения (красивости): необязательность "<;"> в конце строки, guards.
    \item Pattern matching для констант простых типов, короткое тело функции.
    \item Разделение переменных на мутабельные и иммутабельные.
    \item Функции высшего порядка.
\end{enumerate}

\textbf{\textit{Возможные дополнения:}}
\begin{enumerate}
    \item Вызов функций с именованными аргументами (в том числе поддержка значений аргументов по умолчанию).
    \item Анонимные функции.
    \item Каррирование и частичное применение.
\end{enumerate}

\textbf{\large{Описание синтаксиса\\}}

%\textbf{Объявление переменных}

\begin{lstlisting}[caption=Объявление переменных]
mut x: Int = 0, y = 3
let z = true              // `z` has type Bool
mut t: Int = 3, k = false // variables of different types in one line
\end{lstlisting}

Ключевое слово \texttt{mut} свидетельствует о создании мутабельной переменной, \texttt{let} "--- иммутабельной; наличие типа необязательно, а инициализация переменных должна присутствовать.\\ 

%\textbf{Объявление функции}

\begin{lstlisting}[caption=Объявление функции]
f : (b: Bool) -> (mut x: Int) -> (y: Int) -> Int {
    let z = x + 10
    return z
}
\end{lstlisting}

Аргументы разделяются последовательностью символов \texttt{->}, последний тип не имеет имени переменной "--- это возвращаемый тип функции (хотя в теории он мог бы иметь, например в PascalABC он имеет неявное имя переменной result, или же сделать что-то аналогичное этой фишки в Go). Сразу после типа идёт блок, в котором находится тело функции. Блок обязательно должен содержать ключевое слово \texttt{return}, если возвращаемым типом функции не является \texttt{Unit} (аналог \texttt{void}).
Также возможно разделить объявление и реализацию функции в случае pattern matching'a согласно следующему синтаксису (заодно показывающему некоторые особенности языка):

\begin{lstlisting}[caption=Pattern matching]
f : (b: Bool) -> (mut x: Int) -> (y: Int) -> Int
f false ... = x + 10
f (y = 0) {
    x = x - 3
    let a = x / 2
    return x + a
}
f (y = 1) 
    | x > 1 = x - 1
    | else    { let t = x % 2; return t }
f ... = x + 1
\end{lstlisting}

Многоточие указывает на неявное присутствие всех аргументов слева от =, чтобы в будущем не возникло проблем, если захочется поддержать $\eta$-редукцию.
Реализация в виде $\{\}$-блока может быть только последней. Многоточие обязательно, если не указывается какой-то аргумент и затем следует =, справа от которого может быть только некоторое выражение.\\

Ниже приводится пример функции быстрого возведения в степень, демонстрирующий остальные синтаксические особенности языка (вызов функции, условный оператор, циклы, чтение и запись в консоль):

\begin{lstlisting}[caption=Бинарное возведение в степень]
binPow : Unit {
    mut k: Int = 0, n: Int = 0
    read k // space-separated arguments list
    read n
    mut res = 1
    while k > 0 {
        if k % 2 == 1 {  
            res = res * n
        } else {
            skip // `skip` is empty operator
        }
        n = n * n
        k = k / 2
    }
    print res
}
\end{lstlisting}

При передаче в качестве аргумента функции другой функции указывать имена переменных аргументов передаевой функции необязательно. В данный момент в этом вообще не будет смысла, так как не поддерживается вызов с именованными аргументами, но теоретически это возможно.\\

\begin{lstlisting}[caption=Передача функции в качестве аргумента]
decrementAndCheck : (mut x: Int) -> (p: Int -> Bool) -> Bool {
    x = x - 1
    return (p x)  
}
\end{lstlisting}

\end{document}